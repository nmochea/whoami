<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #0e0e0e;
      color: #e6e6e6;
      padding: 20px;
    }
    h1 {
      margin: 0 0 8px 0;
      font-size: 22px;
    }
    pre {
      background: #111;
      color: #0f0;
      padding: 14px;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 70vh;
      overflow: auto;
    }
    .meta {
      font-size: 13px;
      opacity: 0.8;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <h1>Yandex Bridge Auto‑Extraction</h1>
  <div class="meta">
    Runs automatically on page load · timestamp:
    <span id="ts"></span>
  </div>

  <pre id="out">Waiting for execution…</pre>

<script>
(function () {
  const outEl = document.getElementById("out");
  document.getElementById("ts").textContent = String(Date.now());

  function log(s) {
    outEl.textContent += s + "\n";
  }

  function safe(fn) {
    try {
      return fn();
    } catch (e) {
      return { __error: String(e) };
    }
  }

  function isCallable(v) {
    return typeof v === "function";
  }

  function looksLikeDispatcher(name, fn) {
    return (
      isCallable(fn) &&
      /post|send|call|invoke|dispatch|message/i.test(name)
    );
  }

  function probeCall(fn, ctx) {
    try {
      const r = fn.call(ctx);
      if (r && typeof r.then === "function") return "promise";
      return "sync";
    } catch {
      return "throws";
    }
  }

  function extractYandexBridge() {
    const results = {
      callable: [],
      dispatchers: [],
      namespaces: [],
      suspicious: [],
      protoCallables: [],
    };

    let y;
    try {
      y = window.yandex;
    } catch (e) {
      log("[!] window.yandex inaccessible: " + e);
      return results;
    }

    if (!y) {
      log("[!] window.yandex not present");
      return results;
    }

    log("[*] window.yandex detected");

    // 1) Own keys (Proxy-aware)
    const ownKeys = safe(() => Reflect.ownKeys(y)) || [];
    log("[*] ownKeys: " + JSON.stringify(ownKeys));

    for (const k of ownKeys) {
      let v;
      try {
        v = y[k];
      } catch (e) {
        results.suspicious.push({ name: k, reason: "getter throws" });
        continue;
      }

      if (isCallable(v)) {
        const behavior = probeCall(v, y);
        results.callable.push({ name: k, behavior });

        if (looksLikeDispatcher(k, v)) {
          results.dispatchers.push({ name: k, behavior });
        }
        continue;
      }

      if (v === undefined) {
        results.namespaces.push({ name: k, type: "virtual namespace" });
        continue;
      }

      if (typeof v === "object") {
        results.suspicious.push({
          name: k,
          type: "object namespace",
          keys: safe(() => Reflect.ownKeys(v)),
        });
      }
    }

    // 2) Prototype inspection
    let proto;
    try {
      proto = Object.getPrototypeOf(y);
    } catch {}

    if (proto) {
      const protoKeys = safe(() => Reflect.ownKeys(proto)) || [];
      log("[*] protoKeys: " + JSON.stringify(protoKeys));

      for (const k of protoKeys) {
        let v;
        try {
          v = proto[k];
        } catch {
          continue;
        }

        if (isCallable(v)) {
          const behavior = probeCall(v, y);
          results.protoCallables.push({ name: k, behavior });

          if (looksLikeDispatcher(k, v)) {
            results.dispatchers.push({
              name: k,
              behavior,
              source: "prototype",
            });
          }
        }
      }
    }

    return results;
  }

  log("[*] Starting Yandex bridge extraction…");
  const results = extractYandexBridge();

  log("\n=== CALLABLE ROOT FUNCTIONS ===");
  log(JSON.stringify(results.callable, null, 2));

  log("\n=== DISPATCHER CANDIDATES (REAL ATTACK SURFACE) ===");
  log(JSON.stringify(results.dispatchers, null, 2));

  log("\n=== VIRTUAL NAMESPACES (NOT CALLABLE) ===");
  log(JSON.stringify(results.namespaces, null, 2));

  log("\n=== PROTOTYPE CALLABLES ===");
  log(JSON.stringify(results.protoCallables, null, 2));

  log("\n=== SUSPICIOUS OBJECTS ===");
  log(JSON.stringify(results.suspicious, null, 2));

  log("\n[*] Extraction complete");
})();
</script>
</body>
</html>
